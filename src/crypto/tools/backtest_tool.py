import pandas as pd
import numpy as np
from typing import Type, Dict
from pydantic import BaseModel, Field
from crewai.tools import BaseTool
import os

class StrategyBackTestInput(BaseModel):
    strategy_id: str = Field(description="Unique identifier of the strategy")
    coin_symbol: str = Field(description="Ticker symbol of the coin")
    entry_rules: str = Field(description="Python expression for entry signal (returns boolean Series)")
    exit_rules: str = Field(description="Python expression for exit signal (returns boolean Series)")
    stop_loss: float = Field(ge=0, le=100, description="Stop-loss percentage (0-100)")
    take_profit: float = Field(ge=0, le=100, description="Take-profit percentage (0-100)")
    allocation: float = Field(ge=0, le=100, description="Percentage of portfolio allocated to this strategy")
    ohlcv_csv_path: str = Field(description="Path to saved CSV of historical OHLCV data")


class BacktestTool(BaseTool):
    name: str = "Dynamic Backtest Tool"
    description: str = (
        "Backtests any trading strategy generated by the ideator on historical OHLCV data. "
    )
    args_schema: Type[BaseModel] = StrategyBackTestInput

    def _run(self, strategy_id: str, coin_symbol: str, entry_rules: str, exit_rules: str, stop_loss: float, take_profit: float, allocation: float, ohlcv_csv_path: str) -> Dict[str, str]: 
        if not os.path.exists(ohlcv_csv_path):
            raise FileNotFoundError(f"CSV not found at {ohlcv_csv_path}")

        df = pd.read_csv(ohlcv_csv_path, parse_dates=True, index_col="timestamp")
        df["position"] = 0

        safe_ns = {"df": df, "np": np}

        entry_signal = pd.Series(eval(entry_rules, {"__builtins__": {}}, safe_ns), index=df.index)
        exit_signal = pd.Series(eval(exit_rules, {"__builtins__": {}}, safe_ns), index=df.index)

        position = 0
        entry_price = 0
        cash = 100_000
        equity_curve = []

        trades = 0
        wins = 0
        losses = 0
        gross_profit = 0
        gross_loss = 0

        for i in range(len(df)):
            price = df["close"].iloc[i]

            # Entry
            if entry_signal.iloc[i] and position == 0:
                position = (cash * allocation / 100) / price
                cash -= position * price
                entry_price = price

            # Exit
            elif exit_signal.iloc[i] and position > 0:
                pnl = (price - entry_price) / entry_price * 100
                if pnl > 0:
                    wins += 1
                    gross_profit += pnl
                else:
                    losses += 1
                    gross_loss += abs(pnl)

                trades += 1
                cash += position * price
                position = 0
                entry_price = 0

            # Stop-loss / Take-profit
            if position > 0:
                drawdown = (price - entry_price) / entry_price * 100
                if drawdown <= -stop_loss or drawdown >= take_profit:
                    pnl = (price - entry_price) / entry_price * 100
                    if pnl > 0:
                        wins += 1
                        gross_profit += pnl
                    else:
                        losses += 1
                        gross_loss += abs(pnl)

                    trades += 1
                    cash += position * price
                    position = 0
                    entry_price = 0

            equity_curve.append(cash + position * price)

        equity_series = pd.Series(equity_curve, index=df.index)
        profit_percent = (equity_series.iloc[-1] / equity_series.iloc[0] - 1) * 100
        max_drawdown_percent = ((equity_series / equity_series.cummax() - 1).min()) * 100
        daily_returns = equity_series.pct_change().dropna()
        sharpe_ratio = (
            (daily_returns.mean() / daily_returns.std()) * np.sqrt(252)
            if daily_returns.std() != 0
            else 0
        )

        win_rate = (wins / trades * 100) if trades > 0 else 0
        profit_factor = (gross_profit / gross_loss) if gross_loss > 0 else float("inf")
        total_return = profit_percent
        trade_count = trades

        if profit_percent > 10 and max_drawdown_percent > -30:
            recommendation = "Keep"
        elif profit_percent < 0:
            recommendation = "Discard"
        else:
            recommendation = "Modify"

        return {
            "strategy_id": strategy_id,
            "coin_symbol": coin_symbol,
            "profit_percent": profit_percent,
            "max_drawdown_percent": max_drawdown_percent,
            "sharpe_ratio": sharpe_ratio,
            "recommendation": recommendation,
            "win_rate": win_rate,
            "profit_factor": profit_factor,
            "total_return": total_return,
            "trade_count": trade_count,
        }
